const { execSync } = require('child_process');
const fs = require('fs-extra');
const path = require('path');

function formatExecFailure(err) {
  const stdout = err && err.stdout ? String(err.stdout) : '';
  const stderr = err && err.stderr ? String(err.stderr) : '';
  const combined = (stderr || stdout || '').trim();
  if (!combined) return '';
  const max = 2000;
  if (combined.length <= max) return combined;
  return combined.slice(-max);
}

async function installQmd(targetDir, options = {}) {
  const { force = false } = options;

  // Require bun but don't mutate global machine state.
  try {
    execSync('bun --version', { stdio: 'ignore' });
  } catch {
    throw new Error('Bun not found. Install bun first (https://bun.sh), then re-run: janebot-cli install qmd');
  }

  const toolsDir = path.join(targetDir, '.tools');
  const qmdDir = path.join(toolsDir, 'qmd');
  await fs.ensureDir(toolsDir);

  if (!await fs.pathExists(qmdDir)) {
    try {
      execSync(`git clone https://github.com/tobi/qmd.git "${qmdDir}"`, {
        stdio: ['ignore', 'pipe', 'pipe'],
        timeout: 120000
      });
    } catch (e) {
      const detail = formatExecFailure(e);
      throw new Error(`Failed to clone QMD into ${qmdDir}.${detail ? `\n${detail}` : ''}`);
    }
  } else {
    // Basic sanity check so we don't run bun install in a random directory.
    const gitDir = path.join(qmdDir, '.git');
    if (!await fs.pathExists(gitDir)) {
      throw new Error(`Existing QMD directory is not a git repo: ${qmdDir} (move it aside or delete it, then re-run)`);
    }
  }

  // Install deps in the vendored qmd dir.
  try {
    execSync('bun install', {
      cwd: qmdDir,
      stdio: ['ignore', 'pipe', 'pipe'],
      timeout: 240000
    });
  } catch (e) {
    const detail = formatExecFailure(e);
    throw new Error(`Failed to install QMD dependencies (bun install) in ${qmdDir}.${detail ? `\n${detail}` : ''}`);
  }

  await writeQmdWrapper(targetDir, { force });

  return { qmdDir, wrapperPath: path.join(targetDir, 'scripts', 'qmd.sh') };
}

async function writeQmdWrapper(targetDir, options = {}) {
  const { force = false } = options;
  const scriptsDir = path.join(targetDir, 'scripts');
  const wrapperPath = path.join(scriptsDir, 'qmd.sh');
  await fs.ensureDir(scriptsDir);

  if (await fs.pathExists(wrapperPath) && !force) return wrapperPath;

  const wrapper = `#!/usr/bin/env bash
 # qmd.sh - QMD search wrapper (vendored)
 # Auto-generated by janebot-cli
 
 set -euo pipefail
 
 SCRIPT_DIR="$(cd "$(dirname "${'${BASH_SOURCE[0]}'}")" && pwd)"
 TARGET_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
 QMD_DIR="$TARGET_DIR/.tools/qmd"
 QMD_INDEX="$TARGET_DIR/.cache/qmd/index.sqlite"
 KNOWLEDGE_DIR="$TARGET_DIR/knowledge"
 MEMORY_DIR="$TARGET_DIR/memory"

run_qmd() {
  if ! command -v bun >/dev/null 2>&1; then
    echo "bun not found. Install bun (https://bun.sh) then retry." >&2
    exit 1
  fi
  if [[ ! -d "$QMD_DIR" ]]; then
    echo "QMD is not installed at $QMD_DIR" >&2
    printf 'Run: janebot-cli install qmd -d %q\n' "$TARGET_DIR" >&2
    exit 1
  fi
  (cd "$QMD_DIR" && bun run qmd "$@")
}

mkdir -p "$(dirname "$QMD_INDEX")"

case "${'${1:-}'}" in
  search)
    run_qmd search "${'${2:-}'}" --index "$QMD_INDEX" --collection "$KNOWLEDGE_DIR" --collection "$MEMORY_DIR"
    ;;
  query)
    run_qmd query "${'${2:-}'}" --index "$QMD_INDEX" --collection "$KNOWLEDGE_DIR" --collection "$MEMORY_DIR"
    ;;
  get)
    run_qmd get "${'${2:-}'}" --collection "$KNOWLEDGE_DIR" --collection "$MEMORY_DIR"
    ;;
  update)
    run_qmd index --collection "$KNOWLEDGE_DIR" --collection "$MEMORY_DIR" --output "$QMD_INDEX"
    ;;
  *)
    echo "Usage: qmd.sh {search|query|get|update} <args>" >&2
    exit 1
    ;;
esac
`;

  await fs.writeFile(wrapperPath, wrapper);
  await fs.chmod(wrapperPath, 0o755);
  return wrapperPath;
}

module.exports = { installQmd, writeQmdWrapper };
