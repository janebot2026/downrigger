const fs = require('fs-extra');
const path = require('path');

async function setupScripts(targetDir, options = {}) {
  const { force = false } = options;
  const scriptsDir = path.join(targetDir, 'scripts');
  await fs.ensureDir(scriptsDir);
  
  // Track created scripts
  const created = [];
  
  // Time sync script - writes to single state file (not memory bloat)
  const logDatetimeScript = `#!/usr/bin/env bash
 # log_datetime.sh - Update time-sync reference file
 # Run every minute via cron
 # Auto-generated by janebot-cli
 
 set -euo pipefail

 stamp() {
   date -Iseconds 2>/dev/null || date -u "+%Y-%m-%dT%H:%M:%SZ"
 }
 
 STATE_DIR="${targetDir}/.local/state/clawdbot"
 mkdir -p "$STATE_DIR"
 
 stamp > "$STATE_DIR/time-sync.txt"
 `;

  const logPath = path.join(scriptsDir, 'log_datetime.sh');
  if (!await fs.pathExists(logPath) || force) {
    await fs.writeFile(logPath, logDatetimeScript);
    await fs.chmod(logPath, 0o755);
    created.push('log_datetime.sh');
  }
  
  // Env snapshot script - logs system state hourly
  const envSnapshotScript = `#!/usr/bin/env bash
 # log_env_snapshot.sh - Log environment state
 # Run hourly via cron
 # Auto-generated by janebot-cli
 
 set -euo pipefail

 stamp() {
   date -Iseconds 2>/dev/null || date -u "+%Y-%m-%dT%H:%M:%SZ"
 }
 
 MEMORY_DIR="${targetDir}/memory"
 TODAY=$(date +%Y-%m-%d)
 STAMP=$(stamp)

mkdir -p "$MEMORY_DIR"
FILE="$MEMORY_DIR/$TODAY.md"

# Gather system info
HOST=$(hostname)
KERNEL=$(uname -r)
UPTIME=$(uptime -p 2>/dev/null || uptime | awk -F',' '{print $1}')
LOAD=$(uptime | awk -F'load average:' '{print $2}' | xargs)
DISK=$(df -h / | tail -1 | awk '{print $5}')

 echo "[env] $STAMP host=$HOST kernel=$KERNEL uptime=\\"$UPTIME\\" load=$LOAD disk=$DISK" >> "$FILE"
 `;

  const envPath = path.join(scriptsDir, 'log_env_snapshot.sh');
  if (!await fs.pathExists(envPath) || force) {
    await fs.writeFile(envPath, envSnapshotScript);
    await fs.chmod(envPath, 0o755);
    created.push('log_env_snapshot.sh');
  }
  
  // Models and cron check script
  const modelsCronScript = `#!/usr/bin/env bash
 # log_models_and_cron.sh - Log current model and cron status
 # Run hourly at :30 via cron
 # Auto-generated by janebot-cli
 
 set -euo pipefail

 stamp() {
   date -Iseconds 2>/dev/null || date -u "+%Y-%m-%dT%H:%M:%SZ"
 }
 
 MEMORY_DIR="${targetDir}/memory"
 TODAY=$(date +%Y-%m-%d)
 STAMP=$(stamp)

mkdir -p "$MEMORY_DIR"
FILE="$MEMORY_DIR/$TODAY.md"

# Get default model from openclaw config
MODEL=$(grep -o '"primary": "[^"]*"' ~/.openclaw/openclaw.json 2>/dev/null | head -1 | cut -d'"' -f4 || echo "unknown")

echo "[models] $STAMP default=$MODEL" >> "$FILE"

# Count cron jobs
CRON_COUNT=$(openclaw cron list 2>/dev/null | grep -c "cron" || echo "0")
echo "[cron-check] $STAMP jobs=$CRON_COUNT" >> "$FILE"
`;

  const modelsPath = path.join(scriptsDir, 'log_models_and_cron.sh');
  if (!await fs.pathExists(modelsPath) || force) {
    await fs.writeFile(modelsPath, modelsCronScript);
    await fs.chmod(modelsPath, 0o755);
    created.push('log_models_and_cron.sh');
  }
  
  // Weekly synthesis script
  const weeklySynthesisScript = `#!/usr/bin/env bash
 # weekly-synthesis.sh â€” Apply memory decay and regenerate summaries
 # Run weekly as part of cron
 # Auto-generated by janebot-cli
 
 set -euo pipefail

 stamp() {
   date -Iseconds 2>/dev/null || date -u "+%Y-%m-%dT%H:%M:%SZ"
 }

KNOWLEDGE_DIR="${targetDir}/knowledge"
TODAY=$(date +%Y-%m-%d)
SEVEN_DAYS_AGO=$(date -d '7 days ago' +%Y-%m-%d 2>/dev/null || date -v-7d +%Y-%m-%d)
THIRTY_DAYS_AGO=$(date -d '30 days ago' +%Y-%m-%d 2>/dev/null || date -v-30d +%Y-%m-%d)

 echo "[$(stamp)] Starting weekly synthesis..."

# Apply decay and regenerate summaries (single Node invocation)
export KNOWLEDGE_DIR TODAY SEVEN_DAYS_AGO THIRTY_DAYS_AGO

node << 'NODE_EOF'
const fs = require('fs');
const path = require('path');

const knowledgeDir = process.env.KNOWLEDGE_DIR;
if (!knowledgeDir) process.exit(0);

const sevenDaysAgo = new Date(process.env.SEVEN_DAYS_AGO);
const thirtyDaysAgo = new Date(process.env.THIRTY_DAYS_AGO);

function getTier(fact) {
    const lastAccessed = new Date(fact.lastAccessed || fact.timestamp);
    const accessCount = fact.accessCount || 0;
    const frequencyBonus = accessCount >= 10 ? 7 : accessCount >= 5 ? 3 : 0;
    const effectiveDate = new Date(lastAccessed);
    effectiveDate.setDate(effectiveDate.getDate() + frequencyBonus);
    
    if (effectiveDate >= sevenDaysAgo) return 'hot';
    if (effectiveDate >= thirtyDaysAgo) return 'warm';
    return 'cold';
}

function listItemsJson(rootDir) {
    const out = [];
    const stack = [rootDir];

    while (stack.length > 0) {
        const current = stack.pop();
        let entries;
        try {
            entries = fs.readdirSync(current, { withFileTypes: true });
        } catch (e) {
            continue;
        }

        for (const ent of entries) {
            const full = path.join(current, ent.name);
            if (ent.isDirectory()) {
                stack.push(full);
            } else if (ent.isFile() && ent.name === 'items.json') {
                out.push(full);
            }
        }
    }

    return out;
}

const itemFiles = listItemsJson(knowledgeDir);

for (const itemsPath of itemFiles) {
    let items;
    try {
        items = JSON.parse(fs.readFileSync(itemsPath, 'utf8'));
    } catch (e) {
        continue;
    }

    const activeItems = items.filter(f => f && f.status === 'active');

    const tierOrder = { hot: 0, warm: 1, cold: 2 };
    const withTier = activeItems.map(f => ({ fact: f, tier: getTier(f) }));
    withTier.sort((a, b) => {
        if (tierOrder[a.tier] !== tierOrder[b.tier]) {
            return tierOrder[a.tier] - tierOrder[b.tier];
        }
        return (b.fact.accessCount || 0) - (a.fact.accessCount || 0);
    });

    const hotFacts = withTier.filter(x => x.tier === 'hot').map(x => x.fact);
    const warmFacts = withTier.filter(x => x.tier === 'warm').map(x => x.fact);
    const coldCount = withTier.filter(x => x.tier === 'cold').length;

    const entityName = path.basename(path.dirname(itemsPath));
    const summaryPath = path.join(path.dirname(itemsPath), 'summary.md');

    let summary = '# ' + entityName + '\\n\\n';
    summary += '*Last synthesized: ' + process.env.TODAY + '*\\n\\n';

    if (hotFacts.length > 0) {
        summary += '## Hot Facts (Accessed within 7 days)\\n\\n';
        hotFacts.forEach(f => {
            summary += '- **' + f.category + '**: ' + f.fact + ' [' + (f.accessCount || 0) + ' accesses]\\n';
        });
        summary += '\\n';
    }

    if (warmFacts.length > 0) {
        summary += '## Warm Facts (Accessed 8-30 days ago)\\n\\n';
        warmFacts.slice(0, 10).forEach(f => {
            summary += '- **' + f.category + '**: ' + f.fact + ' [' + (f.accessCount || 0) + ' accesses]\\n';
        });
        summary += '\\n';
    }

    summary += '## Stats\\n\\n';
    summary += '- **Hot facts**: ' + hotFacts.length + '\\n';
    summary += '- **Warm facts**: ' + warmFacts.length + '\\n';
    summary += '- **Cold facts**: ' + coldCount + '\\n';
    summary += '- **Total active**: ' + activeItems.length + '\\n';

    fs.writeFileSync(summaryPath, summary);
    console.log('Processing: ' + entityName);
    console.log('  - Hot: ' + hotFacts.length + ', Warm: ' + warmFacts.length + ', Cold: ' + coldCount);
}
NODE_EOF

 echo "[$(stamp)] Weekly synthesis complete."
 `;

  const weeklyPath = path.join(scriptsDir, 'weekly-synthesis.sh');
  if (!await fs.pathExists(weeklyPath) || force) {
    await fs.writeFile(weeklyPath, weeklySynthesisScript);
    await fs.chmod(weeklyPath, 0o755);
    created.push('weekly-synthesis.sh');
  }
  
  // Git workspace sweep script
  const gitSweepScript = `#!/usr/bin/env bash
  # git_workspace_sweep.sh - Log repo status (optional auto-commit/push)
  # Run every 4 hours via cron
  # Auto-generated by janebot-cli

 set -euo pipefail

  stamp() {
    date -Iseconds 2>/dev/null || date -u "+%Y-%m-%dT%H:%M:%SZ"
  }

  is_secret_path() {
    case "$1" in
      .env|*.env|*.pem|*.p12|*.pfx|id_rsa|id_ed25519|*credentials*.json|*secrets*|secrets.*)
        return 0
        ;;
    esac
    return 1
  }

 AUTOCOMMIT=0
 PUSH=0

 for arg in "$@"; do
   case "$arg" in
     --autocommit) AUTOCOMMIT=1 ;;
     --push) PUSH=1 ;;
   esac
 done
 
 WORKSPACE_ROOT="${targetDir}"
 REPO_LIST="${targetDir}/WORKSPACE_REPOS.txt"
 
 echo "[$(stamp)] Starting git sweep..."

# Create repo list if it doesn't exist
if [ ! -f "$REPO_LIST" ]; then
    echo "$WORKSPACE_ROOT" > "$REPO_LIST"
fi

  while IFS= read -r repo_path; do
      [ -z "$repo_path" ] && continue
      [ ! -d "$repo_path/.git" ] && continue
      
      repo_name="$(basename "$repo_path")"
      cd "$repo_path" || continue
      
      # Log status
       status=$(git status --short)
       if [ -n "$status" ]; then
           echo "[repo] $repo_name: $(echo "$status" | wc -l) modified files"

           did_commit=0
           if [ "$AUTOCOMMIT" -eq 1 ]; then
             # Guardrail: skip autocommit if common secret paths are modified.
             has_secret=0
             while IFS= read -r -d '' entry; do
               path_part="${'${entry:3}'}"
               path_part="${'${path_part##* -> }'}"
               if is_secret_path "$path_part"; then
                 echo "[repo] $repo_name: autocommit skipped (potential secret file: $path_part)"
                 has_secret=1
                 break
               fi
             done < <(git status --porcelain -z)

             if [ "$has_secret" -eq 0 ]; then
               git add -A
               if git commit -m "auto: sync $(stamp)"; then
                 did_commit=1
               fi
             fi
           else
             echo "[repo] $repo_name: autocommit disabled (run with --autocommit to enable)"
           fi

           if [ "$PUSH" -eq 1 ]; then
             if [ "$did_commit" -eq 1 ]; then
               git push 2>/dev/null || true
             else
               echo "[repo] $repo_name: push skipped (no new commit)"
             fi
           fi
       else
           echo "[repo] $repo_name: clean"
       fi
  done < "$REPO_LIST"
 
 echo "[$(stamp)] Git sweep complete."
 `;

  const sweepPath = path.join(scriptsDir, 'git_workspace_sweep.sh');
  if (!await fs.pathExists(sweepPath) || force) {
    await fs.writeFile(sweepPath, gitSweepScript);
    await fs.chmod(sweepPath, 0o755);
    created.push('git_workspace_sweep.sh');
  }
  
  // Create WORKSPACE_REPOS.txt
  const reposPath = path.join(targetDir, 'WORKSPACE_REPOS.txt');
  if (!await fs.pathExists(reposPath)) {
    await fs.writeFile(reposPath, targetDir + '\n');
  }
  
  return created;
}

module.exports = { setupScripts };
